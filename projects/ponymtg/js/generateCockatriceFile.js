window.onload = initialize;

/**
 * Application setup.
 */
function initialize() {
    CARDS = CARDS.concat(FICG_CARDS);
    CARDS = CARDS.concat(IPU_CARDS);

    var htmlElement = document.querySelector('html');
    htmlElement.style.fontFamily = 'monospace';
    var sets = undefined;
    var allSetsName = '[All PonyMTG sets]';

    information = getInformation(CARDS);

    global.urlParameters = getUrlParameters();
    if (Object.keys(global.urlParameters).length > 0) {
        if (global.urlParameters.set !== undefined) {
            if (information.sets.indexOf(global.urlParameters.set) !== -1) {
                sets = [global.urlParameters.set];
            }
            else if (global.urlParameters.set === allSetsName) {
                sets = information.sets;
            }
        }
    }

    if (sets !== undefined) {
        var setName = undefined;
        if (sets.length === 1) {
            setName = sets[0];
        }
        else if (global.urlParameters.set === allSetsName) {
            setName = allSetsName;
        }
        var cockatriceXml = '';
        cockatriceXml += getCockatriceXml(sets);

        var cockatriceXmlHeaderComment = '';
        cockatriceXmlHeaderComment += '<!--\n';
        cockatriceXmlHeaderComment += '    Cockatrice XML file for custom MtG set "'+setName+'"\n';
        cockatriceXmlHeaderComment += '    Generated by PonyMTG on '+(new Date())+'\n';
        cockatriceXmlHeaderComment += '\n';
        cockatriceXmlHeaderComment += '    Save this text data as a file with a .xml extension, then use Cockatrice\'s Import feature to add the file to your local Cockatrice database.\n';
        cockatriceXmlHeaderComment += '-->\n';

        var cockatriceXmlLines = cockatriceXml.split('\n');
        cockatriceXmlLines.splice(1, 0, cockatriceXmlHeaderComment);

        cockatriceXml = cockatriceXmlLines.join('\n');

        var cockatriceXmlHtml = '';
        cockatriceXmlHtml += escapeXml(cockatriceXml);
        cockatriceXmlHtml = cockatriceXmlHtml.replace(/ /g, '&nbsp;');
        cockatriceXmlHtml = cockatriceXmlHtml.replace(/\n/g, '<br />');
        htmlElement.innerHTML = cockatriceXmlHtml;
    }
    else {
        var errorMessageElement = document.createElement('p');
        errorMessageElement.innerHTML = 'ERROR: Couldn\'t find a set for which to generate Cockatrice data. The URL might be incorrect.';
        htmlElement.appendChild(errorMessageElement);
    }
}

/**
 * Returns Cockatrice XML data for the given sets.
 */
function getCockatriceXml(sets) {
    var xml = '';
    // Add the Cockatrice XML set information header.
    xml += '<?xml version="1.0" encoding="UTF-8"?>\n';
    xml += '<cockatrice_carddatabase version="3">\n';
    xml += '    <sets>\n';

    // Get a list of set codes (a set code is the short, usually three-letter code that can be used to refer to the set,
    // eg. "AWW".
    var setCodes = generateUniqueSetCodes(sets);

    // Get a list of unique card names categorized by set. Cockatrice currently has a deficiency whereby it cannot
    // display different images for cards that have the same name (even if those cards are obviously from different
    // sets). To get around this, we are generating unique names for all cards in the specified sets, and using those in
    // place of the actual names.

    // Note that we're making the slightly dangerous assumption that the ordering of the cards in each set contained
    // within this object, will be the same as the ordering of the cards that we're about to run through to generate the
    // XML. We make that assumption in order to be able to match card name to unique name by the index at which each
    // appear in their respective sets. If the ordering is _not_ the same, then cards will be matched to the wrong
    // unique names.
    var uniqueCardNamesBySet = getUniqueCardNames(sets);

    // Populate the `<sets>` part of the XML.
    for (var i=0; i < sets.length; i++) {
        var setName = sets[i];
        var setCode = setCodes[i];
        xml += '        <set>\n';
        xml += '            <name>'+setCode+'</name>\n';
        xml += '            <longname>'+setName+'</longname>\n';
        xml += '        </set>\n';
    }

    xml += '    </sets>\n';

    // Next, populate `<cards>`.
    xml += '    <cards>\n';
    for (var i=0; i < sets.length; i++) {
        var setName = sets[i];
        var setCode = setCodes[i];
        var cards = getCardsFilteredBySet(CARDS, [setName]);

        // Add card data for each card in the set.
        for (var j=0; j < cards.length; j++) {
            var card = cards[j];
            var uniqueCardName = uniqueCardNamesBySet[card.set][j];

            var picURL = undefined;
            if (card.image !== undefined) {
                var baseUrl = window.location.origin;
                baseUrl += window.location.pathname.split('/').slice(0, -1).join('/');
                if (global.sets[card.set] !== undefined) {
                    if (global.sets[card.set].path !== undefined) {
                        var picURL = baseUrl+'/'+global.paths.sets+'/'+global.sets[card.set].path+'/'+card.image;
                    }
                }
            }
            var name = uniqueCardName;

            var manacost = '';
            if (card.cost !== undefined) {
                manacost = card.cost;
                if (card.cost2 !== undefined) {
                    manacost += ' // '+card.cost2;
                }
            }
            
            var type = '';
            if (card.supertype !== undefined) {
                type = card.supertype;
                if (card.subtype !== undefined) {
                    type += ' - '+card.subtype;
                }
            }
            if (card.supertype2 !== undefined) {
                type += ' // '+card.supertype2;
                if (card.subtype2 !== undefined) {
                    type += ' - '+card.subtype2;
                }
            }
                
            var pt = undefined;
            if (card.pt !== undefined) {
                pt = card.pt;
            }
            
            var loyalty = undefined;
            if (card.loyalty !== undefined) {
                loyalty = card.loyalty;
            }
            
            // Cockatrice has a special `tablerow` parameter which it uses internally to decide where cards should be
            // placed on the board. This generally depends on the card's type.
            var tablerow = 1;
            if (/Land/i.test(type)) {
               tablerow = 0; 
            }
            else if (/Creature/i.test(type)) {
               tablerow = 2; 
            }
            else if (
                /Instant/i.test(type)
                || /Sorcery/i.test(type)
            ) {
               tablerow = 3; 
            }

            var text = '';
            if (card.text !== undefined) {
                text = card.text;
            }

            // Get a list of colors present in this card.
            var colors = [];
            var manaTypes = getCardManaTypes(card);
            var cmc = getCardConvertedManaCost(card);
            for (var k=0; k < manaTypes.length; k++) {
                if (global.mappings.manaTypesToRepresentativeSymbols[manaTypes[k]] !== undefined) {
                    var color = global.mappings.manaTypesToRepresentativeSymbols[manaTypes[k]];
                    if (['W','U','B','R','G'].indexOf(color) === -1) {
                        // If it's not a WUBRG color, ignore it.
                        continue;
                    }
                    colors.push(color);
                }
            }

            // If the card transforms to or from something, add that to the `<related>` tag.
            var related = undefined;
            var reverseRelated = undefined;
            if (card.transformsInto !== undefined) {
                related = card.transformsInto;
            }
            if (card.transformsFrom !== undefined) {
                reverseRelated = card.transformsFrom;
            }
            
            // Assemble the XML for this `<card>` element.
            xml += '        <card>\n'
            xml += '            '+createXmlElementString('name', name);
            if (picURL !== undefined) {
                // Note: the `cards.xsd` schema currently provided on
                // https://github.com/Cockatrice/Cockatrice/wiki/Custom-Cards-&-Sets is incorrect; it mandates that the
                // attribute be called "picUrl", but the Cockatrice client only recognises "picURL".
                xml += '            '+createXmlElementString('set', setCode, {'picURL': picURL});
            }
            else {
                xml += '            '+createXmlElementString('set', setCode);
            }
            for (var k=0; k < colors.length; k++) {
                xml += '            '+createXmlElementString('color', colors[k]);
            }
            if (related !== undefined) {
                xml += '            '+createXmlElementString('related', related);
            }
            if (reverseRelated !== undefined) {
                xml += '            '+createXmlElementString('reverse-related', reverseRelated);
            }
            xml += '            '+createXmlElementString('manacost', manacost);
            //xml += '            '+createXmlElementString('cmc', cmc);
            xml += '            '+createXmlElementString('type', type);
            if (pt !== undefined) {
                xml += '            '+createXmlElementString('pt', pt);
            }
            xml += '            '+createXmlElementString('tablerow', tablerow);
            xml += '            '+createXmlElementString('text', text);
            if (loyalty !== undefined) {
                xml += '            '+createXmlElementString('loyalty', loyalty);
            }
            xml += '        </card>\n';
        }
    }

    xml += '    </cards>\n';
    xml += '</cockatrice_carddatabase>\n';

    return xml;
}

function createXmlElementString(tagName, content, tagAttributes) {
    var xmlElementString = '';

    var openingTag = '<'+tagName;

    if (tagAttributes !== undefined) {
        var tagAttributeNames = Object.keys(tagAttributes);
        for (var i=0; i < tagAttributeNames.length; i++) {
            var tagAttributeName = tagAttributeNames[i]; 
            var tagAttributeValue = tagAttributes[tagAttributeName]; 
            openingTag += ' '+tagAttributeName+'="'+tagAttributeValue+'"';
        }
    }
    openingTag += '>';

    var xmlElementContent = '';
    if (content !== undefined) {
        xmlElementContent = ''+content;
    }
    var closingTag = '</'+tagName+'>';

    xmlElementString += openingTag;
    xmlElementString += escapeXml(xmlElementContent);
    xmlElementString += closingTag;
    xmlElementString += '\n';

    return xmlElementString;
}

function escapeXml(string) {
    var escapedString = string;
    var xmlEntityMappings = {
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        '\'': '&apos;',
    }

    var charactersToBeEscaped = Object.keys(xmlEntityMappings);

    for (var i=0; i < charactersToBeEscaped.length; i++) {
        var characterToBeEscaped = charactersToBeEscaped[i];
        var entityToReplaceWith = xmlEntityMappings[characterToBeEscaped];
        var xmlEntityEscapeRegex = new RegExp(characterToBeEscaped, 'g');
        escapedString = escapedString.replace(xmlEntityEscapeRegex, entityToReplaceWith);
    }

    return escapedString;
}
