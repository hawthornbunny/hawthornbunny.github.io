/*******************************************************************************
 * hyaseq - simple text-based chiptune sequencer
 * by hyasynth
 *
 * TODO:
 * - Add collapsing panels
 * - Add command list collapsing panel
 * - Add playback indicator
 ******************************************************************************/

var global = {
    'version': '1.0.0',
    'audioContext': undefined,
    'noteDataCache': undefined,
    'songInfoIntervalId': undefined,
    'songInfoIntervalDelay': 0.25,
    'defaults': {
        'wavetableSize': 256,
        'tempo': 150,
        'modSweepAmt': 0.1,
        'masterVolume': 0.2,
        'sampleRate': 44100,
    },
    'noteCutoffs': {
        'long': 1,
        'medium': 0.5,
        'short': 0.15,
    },
    'noteVolumes': {
        'loud': 1,
        'medium': 0.5,
        'quiet': 0.25,
    },
    'lfsr': {
        'seed': '0110100001111001', // hy
        'taps': [10, 12, 13, 15]
    },
    'examples': {
        'default song': 'data/examples/default.txt',
        'simple scale': 'data/examples/simple-scale.txt',
        'arpeggio chords': 'data/examples/arpeggio-chords.txt',
        'techno': 'data/examples/techno.txt',
        'rapid': 'data/examples/rapid.txt',
        'victory': 'data/examples/2sfh-victory.txt',
    },
}

/*******************************************************************************
 * Classes
 ******************************************************************************/

/**
 * Simple 16-bit linear-feedback shift register for generating noise. Based on
 * the Fibonacci implementation described at
 * <https://en.wikipedia.org/wiki/Linear-feedback_shift_register>.
 */
class Lfsr
{
    /**
     * @param {number[]} taps
     * @param {string} seed
     */
    constructor(seed, taps)
    {
        this.register = [];
        for (let i = 0; i < seed.length; i++) {
            const bitChar = seed.charAt(i);
            if (bitChar !== '0' && bitChar !== '1') {
                throw new Error(`Cannot construct LFSR with seed "${seed}"; seed must contain only 0s and 1s`);
            }
            this.register.push(parseInt(seed.charAt(i)));
        }

        for (let i = 0; i < taps.length; i++) {
            const tap = taps[i];

            if (tap >= seed.length) {
                throw new Error(`Cannot construct LFSR with seed "${seed}" and taps ${taps.join(', ')}; tap ${tap} is out of range`);
            }
        }

        this.taps = taps;
    }

    /**
     * Cycle the register and output a single bit.
     *
     * @return {number}
     */
    generateBit()
    {
        const tapBits = this.taps.map(i => this.register[i]); 
        const inputBit = tapBits.reduce(
            (accumulator, currentValue) => accumulator ^ currentValue
        );

        for (let i = this.register.length - 1; i > 0; i--) {
            this.register[i] = this.register[i - 1];
        }

        this.register[0] = inputBit;
        const outputBit = this.register[this.register.length - 1];

        return outputBit;
    }

    /**
     * Generate 8 bits and return the resulting byte value (0 - 255).
     *
     * @return {number}
     */
    generateByte()
    {
        let byteString = '';
        for (let i = 0; i < 8; i++) {
            byteString += this.generateBit();
        }

        return parseInt(byteString, 2);
    }
}

/**
 * Cache object for holding pre-generated note and noise data.
 */
class NoteDataCache
{
    constructor()
    {
        this.noteFreqs = [];
        this.wavetables = {
            'tone': [],
            'noise': [],
        }
    }

    /**
     * Pre-generate the note frequency tables, the tone wavetable (a square
     * wave) and the noise wavetable (256 random signal levels generated by a
     * seeded LSFR).
     */
    generate()
    {
        this.generateNoteFreqs(9);
        this.wavetables.tone = this.generateWavetable(
            global.defaults.wavetableSize,
            (i, size) => i < size / 2 ? -1 : 1
        );

        // Generate an array of noise data for the noise wavetable.
        const lfsr = new Lfsr(global.lfsr.seed, global.lfsr.taps); 

        this.wavetables.noise = this.generateWavetable(
            global.defaults.wavetableSize,
            (i, size) => {
                return ((lfsr.generateByte() / 256) * 2) - 1;
            }
        );
    }

    /**
     * Generate a table which assigns a frequency (pitch) to each named note.
     *
     * @param {number} numOctaves
     * @return {Object}
     */
    generateNoteFreqs(numOctaves)
    {
        // Use the pitch standard of a4 = 440 Hz.
        const a4 = 440;

        // From a4, find c4 (middle c).
        const c4 = getSemitoneFreq(a4, 3) / 2;

        // Get a list of note names, starting at c (so that we can define c as
        // the start of each octave).
        const noteNames = ['c', 'C', 'd', 'D', 'e', 'f', 'F', 'g', 'G', 'a', 'A', 'b'];

        const noteFreqsTable = [];

        // Generate frequencies for each note in each octave.
        for (let octave = 0; octave < numOctaves; octave++) {
            const octaveFreqs = {};
            for (let semitone = 0; semitone < noteNames.length; semitone++) {
                const octave4Freq = getSemitoneFreq(c4, semitone);
                const octave0Freq = octave4Freq * Math.pow(2, -4);
                const octaveFreq = octave0Freq * Math.pow(2, octave);
                const noteName = noteNames[semitone];

                octaveFreqs[noteName] = octaveFreq;
            }

            noteFreqsTable.push(octaveFreqs);
        }

        if (!nearlyEqual(noteFreqsTable[4]['a'], 440, 1e-8)) {
            throw new Error(`Error while generating note frequency data; a4 should be 440 Hz, but it was calculated as ${noteFreqsTable[4]['a']}`);
        }

        this.noteFreqs = noteFreqsTable;
    }

    /**
     * Generate a wavetable of the given number of entries, where the entry at index i is populated by the function `func(i, size)`.
     * @param {number} size
     * @param {function} func
     * @return {number[]}
     */
    generateWavetable(size, func)
    {
        const wavetable = [];

        for (let i = 0; i < size; i++) {
            wavetable.push(func(i, size));
        }

        return wavetable;
    }
}

/**
 * Data object representing a note of a sequence.
 */
class Note
{
    /**
     * @param {string} noteName
     * @param {number} octave
     * @param {string} cutoffName
     * @param {number} modulation
     * @param {string} volumeName
     */
    constructor(noteName, octave, cutoffName, modulation, volumeName)
    {
        this.noteName = noteName;
        this.octave = octave;
        this.cutoffName = cutoffName;
        this.modulation = modulation;
        this.volumeName = volumeName;
    }

    /**
     * Look up and return the frequency that corresponds to this note.
     *
     * @return {number}
     */
    getFreq()
    {
        return global.noteDataCache.noteFreqs[this.octave][this.noteName];
    }

    /**
     * Look up and return the cutoff (ie. note length) that corresponds to this
     * note.
     *
     * @return {number}
     */
    getCutoff()
    {
        return global.noteCutoffs[this.cutoffName];
    }

    /**
     * Look up and return the volume that corresponds to this note.
     *
     * @return {number}
     */
    getVolume()
    {
        return global.noteVolumes[this.volumeName];
    }
}

/**
 * Simple container for song data. This class should map more or less directly
 * with the representation entered by the user.
 *
 */
class Song
{
    constructor()
    {
        this.tempo = global.defaults.tempo;
        this.sequences = [];
        this.orders = [];
    }

    /**
     * Process this song data into a ProcessedSong, which contains all of the
     * audio data (note tracks, sample list, timing info) needed for playback.
     *
     * @return {ProcessedSong}
     */
    process()
    {
        // The number of beats per bar is defined to be the length of the
        // longest sequence.
        let beatsPerBar = null;

        if (this.sequences.length > 0) {
            const sortedSeqs = this.sequences.toSorted((a, b) => b.length - a.length);
            beatsPerBar = sortedSeqs[0].length;
        }

        // To allow for more rapid song creation, the user can omit orders
        // entirely; if they do, we instead pretend that each sequence
        // represents an order consisting of that sequence only. We'll create
        // those "dummy orders" now, as part of the expansion process.
        let orders = this.orders;

        if (orders.length === 0) {
            orders = this.sequences.map((seq, idx) => [idx + 1]);
        }

        // The number of bars in the song is defined to be the length of the
        // longest order list.
        let numBars = null;

        if (orders.length > 0) {
            const sortedOrders = orders.toSorted((a, b) => b.length - a.length);
            numBars = sortedOrders[0].length;
        }

        // The duration of a beat (in seconds) is calculated from the song's
        // tempo (given in bpm, beats per minute).
        const beatDuration = 60 / this.tempo;

        // Quick anonymous decorator which, given a length, returns a function
        // to pad an array to that length by looping its elements. (I used a
        // decorator so that I can pass the resulting function to `map` calls).
        const padArray = length =>
            array => {
                const paddedArray = [];
                for (let i = 0; i < length; i++) {
                    paddedArray.push(array[i % array.length]);
                }

                return paddedArray;
            };

        // Pad each sequence to fill a full bar, looping the beats if necessary.
        const paddedSequences = this.sequences.map(padArray(beatsPerBar));

        // Pad each order list to the length of the song, looping the sequences
        // if necessary.
        const paddedOrders = orders.map(padArray(numBars));

        // Create an "empty" sequence which is just a bar full of rest notes, so
        // that we can use it to replace rest orders.
        const emptySequence = padArray(beatsPerBar)(['--']);

        // Now that we have a complete list of all orders, and complete
        // sequences, we can simply generate a grid of notes representing the
        // entire song. More specifically, we generate a number of "tracks",
        // where each track is a list of notes. All tracks are the same length,
        // the number of beats in the song.
        const noteTracks = [];

        for (let i = 0; i < paddedOrders.length; i++) {
            const order = paddedOrders[i];
            let noteTrack = [];

            for (let j = 0; j < order.length; j++) {
                let seq = undefined;

                if (typeof order[j] === 'string' && isRepeatedChar(order[j], '-')) {
                    // If the order specifies a hyphen (or multiple hyphens),
                    // this indicates a rest that lasts for an entire bar - or,
                    // in other words, a sequence which consists of only rests.
                    // In this case, we supply an empty sequence.
                    seq = emptySequence;
                } else {
                    const seqIndex = order[j] - 1;
                    seq = paddedSequences[seqIndex];
                    if (seq === undefined) {
                        throw new Error(`Cannot process song; order ${i+1} refers to sequence ${seqIndex + 1}, which has not been defined`);
                    }
                }

                noteTrack = noteTrack.concat(seq);
            }

            noteTracks.push(noteTrack);
        }

        // Finally, now that we have a list of note tracks, we can generate the
        // actual audio samples for each note in those tracks. To save on
        // generation time and memory, we only generate each specific note once
        // and store it in a dictionary. Later instances of the same note value
        // are skipped, as they will use the same audio data as the first
        // instance.
        const sampleDict = {};

        for (let i = 0; i < noteTracks.length; i++) {
            const noteTrack = noteTracks[i];

            for (let j = 0; j < noteTrack.length; j++) {
                const note = noteTrack[j];
                // Skip this note if we've already generated a sample for it.
                if (sampleDict[note] !== undefined) {
                    continue;
                }

                const sample = generateSample(note, beatDuration);
                sampleDict[note] = sample;
            }
        }

        return new ProcessedSong(beatDuration, beatsPerBar, noteTracks, sampleDict);
    }

}

/**
 * Data object representing a processed song, which contains all of the timing
 * information, note information, and audio samples needed for playback.
 */
class ProcessedSong
{
    /**
     * @param {number} beatDuration
     * @param {number} beatsPerBar
     * @param {string[][]} noteTracks
     * @param {Object} sampleDict
     */
    constructor(beatDuration, beatsPerBar, noteTracks, sampleDict)
    {
        this.beatDuration = beatDuration;
        this.beatsPerBar = beatsPerBar;
        this.noteTracks = noteTracks;
        this.sampleDict = sampleDict;
    }

    /**
     * Calculate and return the song's duration in seconds.
     *
     * @return {number}
     */
    getDuration()
    {
        return this.beatDuration * this.getNumberOfBeats();
    }

    /**
     * Calculate and return the total number of beats in the song (counting
     * concurrent beats as one beat).
     *
     * @return {number}
     */
    getNumberOfBeats()
    {
        return this.noteTracks[0].length;
    }

    /**
     * Calculate and return the number of bars in the song.
     *
     * @return {number}
     */
    getNumberOfBars()
    {
        return this.getNumberOfBeats() / this.beatsPerBar;
    }
}

/*******************************************************************************
 * Main application
 ******************************************************************************/

/**
 * Given a song script, parse it and return the resulting Song data object.
 *
 * @param {string} script
 * @return {Song}
 */
const parseScript = function parseScript(script)
{
    const delimiter = /\s+/;

    const song = new Song();

    let lines = script.split('\n');
    lines = lines.filter(line => line.length > 0);

    for (let i = 0; i < lines.length; i++) {
        let line = lines[i];
        line = line.trim();

        // Ignore comments (lines that start with #)
        if (line.charAt(0) === '#') {
            continue;
        }

        const terms = line.split(delimiter);
        let command = terms[0];
        command = command.replace(':', '');
        const params = terms.slice(1);

        switch (command) {
            case 'tempo':
                song.tempo = parseInt(params[0]);
                break;
            case 'seq':
                const sequence = params;
                song.sequences.push(sequence);
                break;
            case 'order':
                let order = params.map(
                    i => {
                        // The user is allowed to specify - (or any number of
                        // hyphens) to represent an empty sequence in an order -
                        // that is, a sequence which plays for the length of a
                        // bar, but is silent.
                        if (isRepeatedChar(i, '-')) {
                            return i;
                        }

                        return parseInt(i);
                    }
                );
                song.orders.push(order);
                break;
            default:
                throw new Error(
                    `Cannot parse script; unknown command "${command}" at script line ${i+1}`
                );
                break;
        }
    }

    if (song.sequences.length === 0) {
        throw new Error('Cannot parse script; no sequences have been defined. Use the seq: command to define a sequence of notes.');
    }

    return song;
};

/**
 * Given a note string (eg. "c2", "G4a"), create and return a Note object
 * representing that note. Throw an error if the note syntax is invalid.
 *
 * @param {string} noteString
 * @return {Note}
 * @throws {Error}
 */
const parseNoteString = function parseNoteString(noteString)
{
    if (noteString.length < 2 || noteString.length > 3) {
        throw new Error(`Cannot parse note string "${noteString}"; note strings must be 2 or 3 characters in length`);
    }

    // If the note string is a rest, return null, representing no note.
    if (noteString === '---' || noteString === '--') {
        return null;
    }

    // Parse the 1st character (note name)
    const noteName = noteString.charAt(0);

    const validNoteNames = [
        'a', 'A', 'b', 'c', 'C', 'd', 'D', 'e', 'f', 'F', 'g', 'G', 'n'
    ];

    if (validNoteNames.indexOf(noteName) === -1) {
        throw new Error(`Cannot parse note string "${noteString}"; note name "${noteName}" must be a music note (a-g, A, C, D, F, G), or n for noise`);
    }

    // Parse the 2nd character (octave/note cutoff)
    const octCutChar = noteString.charAt(1);

    const octCutCharGroups = {
        'long':   'ABCDEFGHIJ',
        'medium': '0123456789',
        'short':  'abcdefghij',
    };

    const octCutCharIndices = {
        'long':   octCutCharGroups.long.indexOf(octCutChar),
        'medium': octCutCharGroups.medium.indexOf(octCutChar),
        'short':  octCutCharGroups.short.indexOf(octCutChar),
    };

    let octave = null;
    let cutoffName = null;

    if (octCutCharIndices.long !== -1) {
        octave = octCutCharIndices.long;
        cutoffName = 'long';
    }

    if (octCutCharIndices.medium !== -1) {
        octave = octCutCharIndices.medium;
        cutoffName = 'medium';
    }

    if (octCutCharIndices.short !== -1) {
        octave = octCutCharIndices.short;
        cutoffName = 'short';
    }

    if (octave === null || cutoffName === null) {
        throw new Error(`Cannot parse note string "${noteString}"; octave/cutoff value "${octCutChar}" must be a number 0-9 (medium-length notes), or a letter A-J (long notes), or a letter a-j (short notes)`);
    }

    // Parse the 3rd character (modulation/volume)
    let modulation = null;
    let volumeName = null;

    if (noteString.length == 2) {
        modulation = 0;
        volumeName = 'medium';
    } else {
        const modVolChar = noteString.charAt(2);

        const modVolCharGroups = {
            'loud':   'ABCDEFGHIJ',
            'medium': '0123456789',
            'quiet':  'abcdefghij',
        };

        const modVolCharIndices = {
            'loud':   modVolCharGroups.loud.indexOf(modVolChar),
            'medium': modVolCharGroups.medium.indexOf(modVolChar),
            'quiet':  modVolCharGroups.quiet.indexOf(modVolChar),
        };

        if (modVolCharIndices.loud !== -1) {
            modulation = modVolCharIndices.loud;
            volumeName = 'loud';
        }

        if (modVolCharIndices.medium !== -1) {
            modulation = modVolCharIndices.medium;
            volumeName = 'medium';
        }

        if (modVolCharIndices.quiet !== -1) {
            modulation = modVolCharIndices.quiet;
            volumeName = 'quiet';
        }

        if (modulation === null || volumeName === null) {
            throw new Error(`Cannot parse note string "${noteString}"; modulation/volume value "${modVolChar}" must be a number 0-9 (medium-volume notes), or a letter A-J (loud notes), or a letter a-j (quiet notes)`);
        }
    }

    const note = new Note(noteName, octave, cutoffName, modulation, volumeName);

    return note;
};

/**
 * Populate the examples list with a predefined set of example scripts.
 */
const addExamplesList = function addExamplesList()
{
    const examplesListDiv = query('#examplesList');

    for (const [name, path] of Object.entries(global.examples)) {
        const exampleButton = create('span', 'exampleButton');
        exampleButton.innerHTML = name;
        exampleButton.dataset.path = path;
        exampleButton.onclick = handleShowExample;

        append(examplesListDiv, exampleButton);
    }
};

/**
 * Fetch and display the example script at the given path.
 *
 * @param {string} path
 */
const showExample = async function showExample(path)
{
    const script = await fetch(path).then(response => response.text());

    const scriptArea = query('#script');
    scriptArea.value = script;

};

/**
 * Print human-readable information about the given song to the song info
 * display.
 *
 * @param {Song} song
 */
const printSongInfo = function printSongInfo(processedSong)
{
    const songInfoPanel = query('#songInfo');
    songInfoPanel.innerHTML = '';

    const songDuration = processedSong.getDuration().toFixed(2);
    let songPlayedFor = 0;
    if (global.audioContext) {
        songPlayedFor = global.audioContext.currentTime.toFixed(2);
    }

    const songProgress = `${songPlayedFor} / ${songDuration}`;

    let songInfo = {
        'Number of tracks': `${processedSong.noteTracks.length}`,
        'Beats per bar': `${processedSong.beatsPerBar}`,
        'Number of bars': `${processedSong.getNumberOfBars()}`,
        'Beat duration': `${processedSong.beatDuration.toFixed(2)} s`,
        'Song progress': `${songProgress} s`,
    }

    let html = '';

    for (let key in songInfo) {
        value = songInfo[key];
        html += `<strong>${key}:</strong> ${value}<br />`;
    };

    songInfoPanel.innerHTML = html;
};

/**
 * Print an error message to the song info display.
 *
 * @param {string} message
 */
const printError = function printError(message)
{
    const songInfoPanel = query('#songInfo');
    songInfoPanel.innerHTML = '';

    let html = `<span class="error-message"><strong>ERROR:</strong> ${message}</span>`;

    songInfoPanel.innerHTML = html;
};

/**
 * Play the given song by generating a buffer of audio sample data from the song
 * data, and connecting it to an audio output node.
 *
 * Note that browsers will usually not allow you to create an audio context
 * arbitrarily; it has to be initiated by deliberate user interaction. In
 * practice, that means that this function will fail unless initiated via an
 * event handler.
 *
 * @param {Song} song
 */
const playSong = function playSong(song)
{
    const playButton = query('#playButton');
    playButton.innerHTML = 'Stop';
    playButton.className = 'stopButton'; 
    playButton.dataset.status = 'playing';

    global.audioContext = new AudioContext();

    const processedSong = song.process();

    printSongInfo(processedSong);

    global.songInfoIntervalId = setInterval(
        () => printSongInfo(processedSong),
        global.songInfoIntervalDelay
    );

    const noteTracks = processedSong.noteTracks;
    const sampleDict = processedSong.sampleDict;

    for (let i = 0; i < noteTracks.length; i++) {
        console.log(`Playing note track ${i}`);
        const noteTrack = noteTracks[i];
        for (let j = 0; j < noteTrack.length; j++) {
            const note = noteTrack[j];
            let buffer = sampleDict[note];

            console.log(buffer);
            const startTime = j * processedSong.beatDuration;

            console.log(`Playing note ${j} (${note}) at time ${startTime}`);
            const source = global.audioContext.createBufferSource();
            source.buffer = buffer;
            source.connect(global.audioContext.destination);
            source.start(startTime);

            if (i === 0 && j === noteTrack.length - 1) {
                // If it's the last note, add an event handler to stop the song
                // when the note finishes playing.
                source.onended = evt => stopSong();
            }
        }
    }
};

/**
 * Close the global audio context to terminate the audio output, and reset the
 * play button.
 */
const stopSong = function stopSong()
{
    const playButton = query('#playButton');
    playButton.innerHTML = 'Play';
    playButton.className = 'playButton'; 
    playButton.dataset.status = 'stopped';

    if (global.audioContext) {
        global.audioContext.close();
    }

    clearInterval(global.songInfoIntervalId);
};

/**
 * Generate a mono-channel audio buffer containing an audio data representation
 * of a given note.
 *
 * @param {string} noteString
 * @param {number} beatDuration
 * @return {AudioBuffer}
 */
const generateSample = function generateSample(noteString, beatDuration)
{
    console.log(`Generating sample for note ${noteString} (beat duration: ${beatDuration}s)`);
    const note = parseNoteString(noteString);

    const sampleRate = global.defaults.sampleRate;
    const sampleLength = beatDuration * sampleRate;

    console.log(`Sample rate: ${sampleRate} Hz`);
    console.log(`Sample length: ${sampleLength} frames`);

    const buffer = new AudioBuffer(
        {
            'length': sampleLength,
            'numberOfChannels': 1,
            'sampleRate': sampleRate
        }
    );

    // If the parsed note is null, it represents a rest ('---' or '--'). In
    // this case, there's no sample data needed as it's silent, but we'll
    // still return an empty minimum-length audio buffer just in case we
    // need to attach events to the sample when playing it (eg. detecting
    // the end of the song).
    if (note === null) {
        return new AudioBuffer(
            {
                'length': 1,
                'numberOfChannels': 1,
                'sampleRate': sampleRate
            }
        );
    }

    // Get the audio buffer's data array. Since the sequencer is
    // mono-channel, we only need to supply data for one channel (channel 0)
    const channelData = buffer.getChannelData(0);

    const modulation = note.modulation;
    const cutoff = note.getCutoff();
    const volume = note.getVolume();

    for (let i = 0; i < sampleLength; i++) {
        let signalValue = 0;

        // Calculate how far through the current beat we are, and therefore
        // how much time (in seconds) the note has been playing for (denoted
        // as tNote). This will allow us to figure out what the signal value
        // should be at this time.
        const beatProgress = i / sampleLength;
        const tNote = beatProgress * beatDuration;

        // If we have passed the cutoff point for the note (as defined by
        // the note effect), return no signal, otherwise calculate the
        // signal value for this frame of the sample.
        if (beatProgress <= cutoff) {
            // To get the signal value for the note at time tNote, we need
            // to know its frequency, and which wavetable the note is using
            // (either tone or noise). We can then index the wavetable at an
            // appropriate point to obtain a signal value.
            let freq = undefined;
            let wavetable = undefined;
            let tableIndex = undefined;

            if (note.noteName === 'n') {
                // Noise notes don't have pitch, only octave. We'll assign
                // a low frequency to octave 0 and double it for each
                // successive octave.
                freq = 1;
                freq *= Math.pow(2, note.octave);
                wavetable = global.noteDataCache.wavetables.noise; 
            } else {
                // Look up the note frequency in the precalculated note
                // frequency table.
                freq = note.getFreq();
                wavetable = global.noteDataCache.wavetables.tone;
            }

            // Using the note frequency (number of cycles per second),
            // calculate how many cycles of the note should have already
            // played at time tNote, and how far through the current cycle
            // the note should be at this point.
            const noteCycles = tNote * freq;
            const noteCycleProgress = noteCycles % 1;

            // Index the wavetable at the current point in the note's cycle.
            // (For example, if the note is 25% of the way through its
            // cycle, index the wavetable at whichever index is closest to
            // 25% of the way through the wavetable).
            tableIndex = noteCycleProgress * wavetable.length;
            tableIndex = Math.floor(tableIndex);

            signalValue = wavetable[tableIndex];

            // Calculate the inversion point - the point in the wave cycle
            // after which the signal should be inverted. Inversion has a
            // similar effect on pulse waves to changing the duty cycle.
            //
            // If the note has a modulation effect, the inversion point is
            // made time-variant so that it sweeps over the course of the
            // beat. At higher levels of modulation, the rapidity of this
            // sweep is increased and happens several times per beat.

            // Calculate how much of the wavetable should be inverted at
            // this point in the beat. For no modulation, this should be 0
            // at all times. Otherwise, the inversion amount should be some
            // multiple of the beat progress, which causes the inversion to
            // sweep smoothly from 0 to some value, producing a nice pulse
            // modulation effect. If the inversion amount is greater than 1
            // (ie. more than the length of the wavetable), wrap it so that
            // it is between 0 and 1.
            let inversionAmt = beatProgress * modulation * global.defaults.modSweepAmt;
            inversionAmt %= 1;

            const inversionPoint = 1 - inversionAmt;

            // Apply an inversion effect by inverting the signal if it is
            // beyond a certain point in its wave cycle. With a pulse wave,
            // this has a similar effect to changing the duty cycle.
            if (noteCycleProgress <= inversionPoint) {
                signalValue = 0 - signalValue;
            }

            signalValue *= volume;
            signalValue *= global.defaults.masterVolume;
        }

        channelData[i] = signalValue;
    }

    return buffer;
};

/**
 * Return the nth semitone above the given frequency. For example, A4 is
 * 440 Hz, so C5 is the note 3 semitones above that.
 *
 * @param {number} freq
 * @param {number} n
 * @return {number}
 */
const getSemitoneFreq = function getSemitoneFreq(freq, n)
{
    return freq * Math.pow(2, n / 12);
};

/**
 * Return true if the given string consists only of repetitions of the given
 * character.
 *
 * @param {string} string
 * @param {string} ch
 */
const isRepeatedChar = function isRepeatedChar(string, ch)
{
    if (typeof string !== 'string') {
        throw new Error(`Cannot check if ${string} consists of repetitions of the character "${ch}"; invalid type (${typeof string})`);
    }

    for (let i = 0; i < string.length; i++) {
        if (string.charAt(i) !== ch) {
            return false;
        }
    }

    return true;
};

/**
 * Entry function. Run tests and initialize the application.
 */
const initialize = async function initialize()
{
    // Run unit tests.
    test();

    // Pre-generate the note data and wavetables.
    global.noteDataCache = new NoteDataCache();
    global.noteDataCache.generate();

    // Initialize the song info panel with a welcome message.
    const songInfoPanel = query('#songInfo');
    let html = '';
    html += `Welcome to <strong>hyaseq v${global.version}</strong>!<br />`;
    html += 'Press the Commands toggle for a list of commands.<br />';
    html += 'Press the Examples toggle for some example songs.<br />';
    html += 'Press Play to listen to the song.';
    songInfoPanel.innerHTML = html;

    // Set up the play button.
    const playButton = query('#playButton');
    playButton.onclick = handlePlayOrStop;

    // Set up the information toggles.
    const commandsToggle = query('#commandsToggle');
    commandsToggle.onclick = (evt) => performToggle('commandsToggle', 'commandsList');
    noteSyntaxToggle.onclick = (evt) => performToggle('noteSyntaxToggle', 'noteSyntax');
    examplesToggle.onclick = (evt) => performToggle('examplesToggle', 'examplesList');

    // Populate the examples list.
    addExamplesList();

    // Load the default song.
    await showExample(global.examples['default song']);
};

/*******************************************************************************
 * Event handlers
 ******************************************************************************/

/**
 * Hide or display the given target depending on whether or not it is already
 * hidden or displayed, and update the triangle graphic on the toggle switch to
 * indicate which way it is toggled.
 *
 * @param {string} toggleId
 * @param {string} toggleTargetId
 */
const performToggle = function performToggle(toggleId, toggleTargetId)
{
    const toggle = query('#' + toggleId);
    const toggleTarget = query('#' + toggleTargetId);
    if (toggleTarget.style.display === 'none') {
        toggleTarget.style.display = 'block';
        toggle.querySelector('.triangle').innerHTML = '▼';
    } else {
        toggleTarget.style.display = 'none';
        toggle.querySelector('.triangle').innerHTML = '▶';
    }
};

/**
 * Handle the show example event (triggered by clicking on an example name).
 *
 * @param {Event} evt
 */
const handleShowExample = function handleShowExample(evt)
{
    const path = evt.target.dataset.path;
    showExample(path);
};

/**
 * Handle either the play event or stop event depending on whether audio is
 * already playing or not.
 *
 * @param {Event} evt
 */
const handlePlayOrStop = function handlePlayOrStop(evt)
{
    const playButton = query('#playButton');
    switch (playButton.dataset.status) {
        case 'playing':
            handleStop(evt);
            break;
        case 'stopped':
            handlePlay(evt);
            break;
    }
            
};

/**
 * Handle the play song event (triggered by clicking the play button).
 *
 * @param {Event} evt
 */
const handlePlay = function handlePlay(evt)
{
    const scriptArea = query('#script');
    try {
        const song = parseScript(scriptArea.value);
        playSong(song);
    } catch (error) {
        printError(error.message);
        console.log(error);
        stopSong();
    }
};

/**
 * Handle the stop song event.
 *
 * @param {Event} evt
 */
const handleStop = function handleStop(evt)
{
    stopSong();
};

/*******************************************************************************
 * Tests
 ******************************************************************************/
const test = function test()
{
};

/*******************************************************************************
 * Shortcut and convenience functions
 ******************************************************************************/

/**
 * Shortcut for `document.querySelector`.
 *
 * @param {string} selector
 * @return {Element}
 */
const query = function query(selector)
{
    return document.querySelector(selector);
};

/**
 * Append multiple children to an element.
 *
 * @param {Element} element
 * @param {...Element} children
 * @return {Element}
 */
const append = function append(element, ...children)
{
    for (const child of children) {
        element.appendChild(child);
    }

    return element;
};

/**
 * Shortcut for `document.createElement`.
 */
const create = function create(tag, className)
{
    const element = document.createElement(tag);

    if (className !== undefined) {
        element.className = className;
    }

    return element;
};

/*******************************************************************************
 * Miscellaneous functions
 ******************************************************************************/

/**
 * Return true if a is within a given margin of b. This is needed to handle
 * JavaScript's occasional floating-point inaccuracies, which prevent testing
 * for equality.
 *
 * @param {number} a
 * @param {number} b
 * @param {number} margin
 * @return {boolean}
 */
const nearlyEqual = function nearlyEqual(a, b, margin)
{
    return a >= b - margin && a <= b + margin;
};

/**
 * Throw an error if the condition fails, with an optional message.
 *
 * @param {boolean} condition
 * @param {string} message
 * @throws {Error}
 */
const assert = function assert(condition, message)
{
    if (!condition) {
        if (message) {
            throw new Error(`Assertion failed: ` + message);
        } else {
            throw new Error(`Assertion failed`);
        }
    }
};

window.onload = initialize;
